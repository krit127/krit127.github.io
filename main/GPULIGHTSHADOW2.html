<!DOCTYPE html>
<html>
<head>
    <title>PBR Shader with UI</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; color: #fff; }
        #ui-container {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .ui-section { border: 1px solid #444; padding: 10px; border-radius: 5px; }
        .ui-section h3 { margin-top: 0; margin-bottom: 10px; font-size: 16px; }
        .ui-button { background-color: #555; border: none; color: white; padding: 5px 10px; text-align: center; text-decoration: none; display: inline-block; font-size: 14px; margin: 2px; cursor: pointer; border-radius: 3px; }
        .ui-button:hover { background-color: #777; }
        input[type="range"] { width: 150px; }
    </style>
</head>
<body>
    <div id="ui-container">
        <div class="ui-section">
            <h3>‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡πÅ‡∏™‡∏á</h3>
            <label>‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏ß‡πà‡∏≤‡∏á:</label>
            <input type="range" id="light-intensity" min="0" max="5" step="0.1" value="2"><br>
            <label>‡∏™‡∏µ‡πÅ‡∏™‡∏á:</label>
            <input type="color" id="light-color" value="#ffffff">
        </div>
        <div class="ui-section">
            <h3>‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÅ‡∏™‡∏á</h3> <!-- üîπ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡πà‡∏ß‡∏ô‡∏ô‡∏µ‡πâ -->
            <label>X:</label><input type="range" id="light-x" min="-50" max="50" step="0.1" value="10"><br>
            <label>Y:</label><input type="range" id="light-y" min="0" max="50" step="0.1" value="20"><br>
            <label>Z:</label><input type="range" id="light-z" min="-50" max="50" step="0.1" value="10">
        </div>
        <div class="ui-section">
            <h3>‡πÄ‡∏á‡∏≤</h3>
            <button id="toggle-shadows" class="ui-button">‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î‡πÄ‡∏á‡∏≤</button>
        </div>
        <div class="ui-section">
            <h3>‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏° MODEL</h3>
            <p>‡πÉ‡∏ä‡πâ‡∏õ‡∏∏‡πà‡∏° WASD + Arrow Up/Down </p>
        </div>
         <div class="ui-section">
        <h3>Material</h3>
        <label>Metallic:</label>
        <input type="range" id="aircraft-metal" min="0" max="1" step="0.01" value="0.5"><br>
        <label>Roughness:</label>
        <input type="range" id="aircraft-rough" min="0" max="1" step="0.01" value="0.5">
    </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/EXRLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script> <!-- üîπ‡πÄ‡∏û‡∏¥‡πà‡∏° TransformControls -->
    <script>
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const scene = new THREE.Scene();

        const exrLoader = new THREE.EXRLoader();
        exrLoader.load(
            "https://krit127.github.io/textures/qwantani_noon_puresky_1k.exr",
            texture => {
                texture.mapping = THREE.EquirectangularReflectionMapping;
                scene.background = texture;
                scene.environment = texture;
                console.log("‚úÖ EXR HDR ‡πÇ‡∏´‡∏•‡∏î‡πÄ‡∏™‡∏£‡πá‡∏à");
            },
            undefined,
            err => console.error("‚ùå ‡πÇ‡∏´‡∏•‡∏î EXR ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ", err)
        );

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(0, 15, 25);
        const controls = new THREE.OrbitControls(camera, renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0x555555);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 2);
        directionalLight.position.set(10,20,10);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 200;
        directionalLight.shadow.camera.left = -100;
        directionalLight.shadow.camera.right = 100;
        directionalLight.shadow.camera.top = 100;
        directionalLight.shadow.camera.bottom = -100;
        directionalLight.shadow.bias = -0.0005;
        scene.add(directionalLight);

        // üîπ Light Helper + TransformControls
        const lightHelper = new THREE.DirectionalLightHelper(directionalLight, 2, 0xffff00);
        scene.add(lightHelper);
        const transformControls = new THREE.TransformControls(camera, renderer.domElement);
        transformControls.attach(directionalLight);
        scene.add(transformControls);
        transformControls.addEventListener('dragging-changed', event => { controls.enabled = !event.value; });

        const texture = new THREE.TextureLoader().load(
            "https://krit127.github.io/textures/brick_crosswalk_diff_1k.jpg",
            () => console.log("‚úÖ Texture ‡πÇ‡∏´‡∏•‡∏î‡πÄ‡∏™‡∏£‡πá‡∏à"),
            undefined,
            err => console.error("‚ùå ‡πÇ‡∏´‡∏•‡∏î texture ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ", err)
        );
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set(5,5);
        const floorMaterial = new THREE.MeshStandardMaterial({ map: texture });
        const floorMesh = new THREE.Mesh(new THREE.PlaneGeometry(100,100), floorMaterial);
        floorMesh.rotation.x = -Math.PI/2;
        floorMesh.receiveShadow = true;
        scene.add(floorMesh);

        // ‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏•
        const loader = new THREE.GLTFLoader();
        let aircraft, building;

        function loadModel(url, position, scale=1, isAircraft=false) {
            loader.load(url, gltf => {
                const obj = gltf.scene;
                obj.traverse(child => { if(child.isMesh){ child.castShadow = true; child.receiveShadow = true; }});
                obj.position.copy(position);
                obj.scale.set(scale,scale,scale);
                scene.add(obj);
                if(isAircraft) aircraft = obj; else building = obj;
                console.log(`‚úÖ ‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏•: ${url}`);
            }, undefined, err => console.error("‚ùå ‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏•‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ", err));
        }

        // üîπ ‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏™‡∏≠‡∏á‡∏ï‡∏±‡∏ß
        loadModel("https://krit127.github.io/CG/model/supermarine_spitfire.glb", new THREE.Vector3(0,0,0), 0.05, true);
        loadModel("https://krit127.github.io/CG/model/small_warehouse.glb", new THREE.Vector3(5,0,-5), 1.2);

        // UI Controls
        document.getElementById('light-intensity').addEventListener('input', e => directionalLight.intensity = parseFloat(e.target.value));
        document.getElementById('light-color').addEventListener('input', e => directionalLight.color.set(e.target.value));
        document.getElementById('toggle-shadows').addEventListener('click', ()=>{
            renderer.shadowMap.enabled = !renderer.shadowMap.enabled;
            scene.traverse(c => { if(c.isMesh){ c.castShadow = renderer.shadowMap.enabled; c.receiveShadow = renderer.shadowMap.enabled;}});
        });

        // üîπ Light position sliders
        const lightX = document.getElementById('light-x');
        const lightY = document.getElementById('light-y');
        const lightZ = document.getElementById('light-z');
        function updateLightPosition(){ directionalLight.position.set(parseFloat(lightX.value), parseFloat(lightY.value), parseFloat(lightZ.value)); }
        lightX.addEventListener('input', updateLightPosition);
        lightY.addEventListener('input', updateLightPosition);
        lightZ.addEventListener('input', updateLightPosition);

        // Aircraft Material sliders
        const metalSlider = document.getElementById('aircraft-metal');
        const roughSlider = document.getElementById('aircraft-rough');
        function updateAircraftMaterial(){
            if(!aircraft) return;
            aircraft.traverse(c=>{ if(c.isMesh && c.material){ c.material.metalness=parseFloat(metalSlider.value); c.material.roughness=parseFloat(roughSlider.value); } });
        }
            metalSlider.addEventListener('input', updateAircraftMaterial);  
            roughSlider.addEventListener('input', updateAircraftMaterial);

        // Keyboard movement (WASD + Arrow Up/Down)
        const keys = {};
        window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
        window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

        function moveAircraft(){
            if(!aircraft) return;
            const speed = 0.2;
            if(keys['w']) aircraft.position.z -= speed;
            if(keys['s']) aircraft.position.z += speed;
            if(keys['a']) aircraft.position.x -= speed;
            if(keys['d']) aircraft.position.x += speed;
            if(keys['arrowup']) aircraft.position.y += speed;
            if(keys['arrowdown']) aircraft.position.y -= speed;
            if(aircraft.position.y < 0) aircraft.position.y = 0;
        }

        function animate(){
            requestAnimationFrame(animate);
            moveAircraft();
            controls.update();
            transformControls.update();
            renderer.render(scene,camera);
        }
        animate();

        window.addEventListener('resize', ()=>{
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
