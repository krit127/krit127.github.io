<!DOCTYPE html>
<html>
<head>
    <title>PBR Shader with UI</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            color: #fff;
        }

        #ui-container {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .ui-section {
            border: 1px solid #444;
            padding: 10px;
            border-radius: 5px;
        }

        .ui-section h3 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 16px;
        }

        .ui-button {
            background-color: #555;
            border: none;
            color: white;
            padding: 5px 10px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 14px;
            margin: 2px;
            cursor: pointer;
            border-radius: 3px;
        }

        .ui-button:hover {
            background-color: #777;
        }

        input[type="range"] {
            width: 150px;
        }
    </style>
</head>
<body>
    <div id="ui-container">
        <div class="ui-section">
            <h3>‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡πÅ‡∏™‡∏á</h3>
            <label>‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏ß‡πà‡∏≤‡∏á:</label>
            <input type="range" id="light-intensity" min="0" max="5" step="0.1" value="2">
            <br>
            <label>‡∏™‡∏µ‡πÅ‡∏™‡∏á:</label>
            <input type="color" id="light-color" value="#ffffff">
        </div>
        <div class="ui-section">
            <h3>‡πÄ‡∏á‡∏≤</h3>
            <button id="toggle-shadows" class="ui-button">‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î‡πÄ‡∏á‡∏≤</button>
        </div>
        <div class="ui-section">
            <h3>‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏´‡∏∏‡πà‡∏ô‡∏¢‡∏ô‡∏ï‡πå</h3>
            <p>‡πÉ‡∏ä‡πâ‡∏õ‡∏∏‡πà‡∏° WASD</p>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/EXRLoader.js"></script>
    <script>
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const scene = new THREE.Scene();

 const exrLoader = new THREE.EXRLoader();
exrLoader.load(
    "https://krit127.github.io/textures/qwantani_noon_puresky_1k.exr",
    function(texture){
        texture.mapping = THREE.EquirectangularReflectionMapping;
        scene.background = texture;
        scene.environment = texture;
        console.log("‚úÖ EXR HDR ‡πÇ‡∏´‡∏•‡∏î‡πÄ‡∏™‡∏£‡πá‡∏à");
    },
    undefined,
    function(err){
        console.error("‚ùå ‡πÇ‡∏´‡∏•‡∏î EXR ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ", err);
    }
);

    

        // ‡∏Å‡∏•‡πâ‡∏≠‡∏á
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 15, 25);
        const controls = new THREE.OrbitControls(camera, renderer.domElement);

        // ‡πÅ‡∏™‡∏á
        const ambientLight = new THREE.AmbientLight(0x555555);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 2);
        directionalLight.position.set(10, 20, 10); // ‡∏¢‡∏Å‡πÑ‡∏ü‡πÉ‡∏´‡πâ‡∏™‡∏π‡∏á‡∏Ç‡∏∂‡πâ‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏á‡∏≤‡∏à‡∏∞‡∏ï‡∏Å‡∏•‡∏á‡∏û‡∏∑‡πâ‡∏ô‡∏Å‡∏ß‡πâ‡∏≤‡∏á‡∏Ç‡∏∂‡πâ‡∏ô
        directionalLight.castShadow = true;

        // ‡∏õ‡∏£‡∏±‡∏ö‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡πÄ‡∏á‡∏≤‡πÉ‡∏´‡πâ‡∏Ñ‡∏°‡∏Ç‡∏∂‡πâ‡∏ô
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;

        // ‡∏Ç‡∏¢‡∏≤‡∏¢‡∏Ç‡∏≠‡∏ö‡πÄ‡∏Ç‡∏ï‡∏Å‡∏≤‡∏£‡∏â‡∏≤‡∏¢‡πÄ‡∏á‡∏≤ (‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡∏°‡∏≤‡∏Å)
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 200; // ‡πÉ‡∏´‡πâ‡πÑ‡∏Å‡∏•‡∏û‡∏≠
        directionalLight.shadow.camera.left = -100;
        directionalLight.shadow.camera.right = 100;
        directionalLight.shadow.camera.top = 100;
        directionalLight.shadow.camera.bottom = -100;

        // ‡πÄ‡∏õ‡∏¥‡∏î bias ‡∏õ‡∏£‡∏±‡∏ö‡πÉ‡∏´‡πâ‡πÄ‡∏á‡∏≤‡πÑ‡∏°‡πà‡∏ã‡πâ‡∏≠‡∏ô
        directionalLight.shadow.bias = -0.0005;

        scene.add(directionalLight);

        // ‡∏û‡∏∑‡πâ‡∏ô
        const texture = new THREE.TextureLoader().load(
            "https://krit127.github.io/textures/brick_crosswalk_diff_1k.jpg",
            () => console.log("‚úÖ Texture ‡πÇ‡∏´‡∏•‡∏î‡πÄ‡∏™‡∏£‡πá‡∏à"),
            undefined,
            err => console.error("‚ùå ‡πÇ‡∏´‡∏•‡∏î texture ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ", err)
        );
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set(5, 5);

        const floorMaterial = new THREE.MeshStandardMaterial({ map: texture });
        const floorGeom = new THREE.PlaneGeometry(100, 100);
        const floorMesh = new THREE.Mesh(floorGeom, floorMaterial);
        floorMesh.rotation.x = -Math.PI / 2;
        floorMesh.receiveShadow = true;
        scene.add(floorMesh);

        // ‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏•
        const loader = new THREE.GLTFLoader();
       let aircraft, building;
;

        function loadModel(url, position, isAircraft = false, scale) {
            loader.load(url, gltf=>{
                const obj = gltf.scene;
                obj.traverse(child=>{
                    if(child.isMesh){
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });

                    obj.position.copy(position);
                    // Apply the scale here
                    obj.scale.set(scale, scale, scale);
                    scene.add(obj);

                        if(isAircraft) aircraft = obj;
                        else building = obj;
                        console.log(`‚úÖ ‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏•: ${url}`);
             }, undefined, err=>console.error("‚ùå ‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏•‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ", err));

        }

        // Call the loadModel function with the new scale parameter
        loadModel("https://krit127.github.io/models/aircraft.glb", new THREE.Vector3(0,0,0), 1, true); // ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ö‡∏¥‡∏ô‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°
        loadModel("https://krit127.github.io/models/building.glb", new THREE.Vector3(5,0,-5), 1.2);        // ‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥


        // UI Controls
        const intensityInput = document.getElementById('light-intensity');
        intensityInput.addEventListener('input', e => {
            directionalLight.intensity = parseFloat(e.target.value);
        });

        const colorInput = document.getElementById('light-color');
        colorInput.addEventListener('input', e => {
            directionalLight.color.set(e.target.value);
        });

        const toggleShadowsButton = document.getElementById('toggle-shadows');
        toggleShadowsButton.addEventListener('click', () => {
            renderer.shadowMap.enabled = !renderer.shadowMap.enabled;
            scene.traverse(child => {
                if (child.isMesh) {
                    child.castShadow = renderer.shadowMap.enabled;
                    child.receiveShadow = renderer.shadowMap.enabled;
                }
            });
            console.log(`üí° ‡πÄ‡∏á‡∏≤: ${renderer.shadowMap.enabled ? '‡πÄ‡∏õ‡∏¥‡∏î' : '‡∏õ‡∏¥‡∏î'}`);
        });

        // Event listener for keyboard controls
        window.addEventListener('keydown', e => {
            const step = 1;
            if (robotModel) {
                switch (e.key) {
                    case "w": robotModel.position.z -= step; break;
                    case "s": robotModel.position.z += step; break;
                    case "a": robotModel.position.x -= step; break;
                    case "d": robotModel.position.x += step; break;
                }
            }
        });

        // Render
        function animate() {
            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }
        animate();
    </script>
</body>
</html>