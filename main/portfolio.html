<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <title>Picking</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body {
      height: 100%;
      margin: 0;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
    /* กล่องข้อความ */
    #infoBox {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 10px;
      border-radius: 6px;
      font-family: sans-serif;
    }
    /* กล่องรูปภาพ */
    #imgBox {
      position: absolute;
      bottom: 10px;
      right: 10px;
      border: 2px solid white;
      border-radius: 6px;
      overflow: hidden;
      width: 150px;
      height: auto;
    }
    #imgBox img {
      display: block;
      width: 100%;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
  <!-- กล่องข้อความ -->
  <div id="infoBox">คลิกที่วัตถุเพื่อดูมุมกล้อง</div>
  <!-- กล่องรูปภาพ -->
  <div id="imgBox"><img src="https://placekitten.com/200/200" alt="demo"></div>

  <script>
    (() => {
      const infoBox = document.getElementById('infoBox');

      // --- Scene / Camera / Renderer ---
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 100);
      camera.position.set(0, 1.2, 4);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(innerWidth, innerHeight);
      document.body.appendChild(renderer.domElement);

      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.target.set(0, 0.5, 0);
      controls.enableDamping = true;

      const grid = new THREE.GridHelper(10, 10, 0x666666, 0x333333);
      grid.position.y = -0.001;
      scene.add(grid);

      const clickable = [];
      let pickedObjPosition = new THREE.Vector3();
      let cameraPosition = new THREE.Vector3(0,1.2,4);

      function addObj(mesh, pos, name) {
        mesh.position.copy(pos);
        mesh.name = name;
        scene.add(mesh);
        clickable.push(mesh);
        return mesh;
      }

      addObj(new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.8, 0.8), new THREE.MeshBasicMaterial({ color: 0xff6b6b })), new THREE.Vector3(-2, 0.4, 0), 'Box');
      const Sphere = addObj(new THREE.Mesh(new THREE.SphereGeometry(0.45, 32, 16), new THREE.MeshBasicMaterial({ color: 0x5dff9b })), new THREE.Vector3(0, 0.45, 0), 'Sphere');
      addObj(new THREE.Mesh(new THREE.ConeGeometry(0.5, 1, 24), new THREE.MeshBasicMaterial({ color: 0x5db6ff })), new THREE.Vector3(2, 0.5, 0), 'Cone');
      const cylinder = addObj(new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 1, 24), new THREE.MeshBasicMaterial({ color: 0xffff00 })), new THREE.Vector3(0, 0.5, -2), 'cylinder');
      const purple = addObj(new THREE.Mesh(new THREE.SphereGeometry(0.45, 32, 16), new THREE.MeshBasicMaterial({ color: 0x800080 })), new THREE.Vector3(0, 0.5, -2), 'Sphere2');

      const VIEWS = {
        Box: { pos: new THREE.Vector3(-3, 1.4, 1.6), tar: new THREE.Vector3(-2, 0.4, 0) },
        Sphere: { pos: new THREE.Vector3(0, 1.8, 3.0), tar: new THREE.Vector3(0, 0.45, 0) },
        Cone: { pos: new THREE.Vector3(3, 1.6, -2.0), tar: new THREE.Vector3(2, 0.5, 0) },
        cylinder: { pos: new THREE.Vector3(0,1.8,3.0), tar: new THREE.Vector3(0, 0.5, -2) },
        purple: { pos: new THREE.Vector3(0,1.8,3.0), tar: new THREE.Vector3(0, 0.5, -2) },
      };

      const raycaster = new THREE.Raycaster();
      const pointer = new THREE.Vector2();

      function setPointer(e) {
        const r = renderer.domElement.getBoundingClientRect();
        const x = (e.clientX ?? e.touches[0].clientX) - r.left;
        const y = (e.clientY ?? e.touches[0].clientY) - r.top;
        pointer.x = (x / r.width) * 2 - 1;
        pointer.y = -(y / r.height) * 2 + 1;
      }

      function onPick(e) {
        setPointer(e);
        raycaster.setFromCamera(pointer, camera);
        const hit = raycaster.intersectObjects(clickable, false)[0];
        if (!hit) return;
        const view = VIEWS[hit.object.name];
        if (!view) return;
        cameraPosition = view.pos;
        pickedObjPosition = hit.object.position;

        // อัปเดตกล่องข้อความตามชื่อวัตถุ
        infoBox.textContent = `คุณเลือก: ${hit.object.name}`;
      }

      renderer.domElement.addEventListener('click', onPick);
      renderer.domElement.addEventListener('touchend', (e) => { onPick(e); }, { passive: true });

      addEventListener('resize', () => {
        camera.aspect = innerWidth / innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
      });

      function lerp(a, b, t) { return a + (b - a) * t; }

      let t = 0.0;
      let cylinderTarget = new THREE.Vector3();

      function loop() {
        controls.update();
        t += 0.01;
        if(t > 1.0) {
          t =0.0;
          cylinderTarget.x = lerp(-2.0, 2.0, Math.random());
          cylinderTarget.y = 0.5;
          cylinderTarget.z = lerp(-4.0, 4.0, Math.random());
        }

        controls.target.lerp(pickedObjPosition, 0.02);
        cylinder.position.lerp(cylinderTarget, 0.02);
        camera.position.lerp(cameraPosition, 0.02);

        renderer.render(scene, camera);
        requestAnimationFrame(loop);
      }
      loop();
    })();
  </script>
</body>
</html>
